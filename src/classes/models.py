from django.db import models
from django.contrib.auth.hashers import make_password
from accounts.models import CustomUser
import uuid

#funtion to generate random but different class ids
def generate_unique_class_id():
    #from classes.models import SchoolClass #commented out since from the same file
    while True:
        new_id = f"CLS-{uuid.uuid4().hex[:8].upper()}"
        if not SchoolClass.objects.filter(class_id=new_id).exists():
            return new_id

# Create your models here.

#this is a class (table)
class SchoolClass(models.Model):
    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE)
    #1. Autogenerated primary key, second ro django ID
    class_id = models.CharField(primary_key=True,max_length=20,default=generate_unique_class_id, help_text="Unique identifier for the class")
    #2. Foreign key to school
    class_school = models.ForeignKey('schools.School', on_delete=models.CASCADE, related_name='classes', help_text="The school owning the class")
    #3. Name of the class
    class_name = models.CharField(max_length=50,default='Grade', help_text="The name of the class e.g -stoic-room ")
    #4. educational level
    CLASS_LEVEL_CHOICES = [ (1, '1'), (2, '2'), (3, '3'), (4, '4'), (5, '5'), (6, '6'), (7, '7'), (8, '8'), (9, '9'), (10, '10'), (11, '11'), (12, '12'), ]
    class_level = models.IntegerField(choices=CLASS_LEVEL_CHOICES,unique=True, help_text="Educational level e.g 7,8,9")
    #5. Class Teacher field
    class_teacher = models.ForeignKey('teachers.Teacher', on_delete=models.SET_NULL, null=True, blank=True, related_name='classes', help_text="Teache assigned to the class")
    #6. class capacity / number of students
    #use Student.objects.filter(student_class=...) to get in sync after prototype
    class_capacity = models.IntegerField(default=0, help_text="Current number of student in the class")
    #7. Optional class stream
    class_stream = models.CharField(max_length=20, null=True, blank=True, help_text="Optional stream Identifierve.g 'A','B'." )
    #8. Class status i.e whether active or archived(graduated)
    STATUS_CHOICES = [ ('Active', 'Active'), ('Archived', 'Archived'),]
    class_status = models.CharField(max_length=10,choices=STATUS_CHOICES, default='Active', help_text="Class status (Active or Archived).")
    #9. Class password to prevent unathorised editing
    #rely on user roles after prototyping
    # class_password = models.CharField( max_length=128, help_text="Hashed password for editing the class data.")
    #10 .Timestamps just like for the school
    class_creation_date = models.DateTimeField(auto_now_add=True, help_text="Time when the class whas created")
    class_updated_date = models.DateTimeField(auto_now=True, help_text="Last time the class was updated")

    #an overide to save class and encrypt password if not
    # def save(self, *args, **kwargs):
    #     #hash the password if new or changed
    #     if not self.class_password.startswith('pbkdf2_'):
    #         self.class_password = make_password(self.class_password)
    #     super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.class_name}-{self.class_level} ({self.class_school.school_name})"